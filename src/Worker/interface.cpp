/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <vector>
#include <string>

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>

#include "callbacks.h"
#include "interface.h"
#include "support.h"

using namespace std;



#define GLADE_HOOKUP_OBJECT(component,widget,name) \
  g_object_set_data_full (G_OBJECT (component), name, \
    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)

#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
  g_object_set_data (G_OBJECT (component), name, widget)


vector<string> to_disp;



char to_display[2000];
//List of Gtk Widgets

  GtkWidget *window1;
  GtkWidget *notebook1;
  GtkWidget *vbox1;
  GtkWidget *label4;
  GtkWidget *scrolledwindow1;
  GtkWidget *textview1;
  GtkWidget *label5;
  GtkWidget *progressbar1;
  GtkWidget *label1;
  GtkWidget *vbox2;
  GtkWidget *label6;
  GtkWidget *scrolledwindow2;
  GtkWidget *textview2;
  GtkWidget *button1;
  GtkWidget *label2;
  GtkWidget *label7;
  GtkWidget *label3;
  string execute_string;
  string command_string;
  
gboolean
exec_timeout( gpointer data )
{
     gtk_text_buffer_set_text(gtk_text_view_get_buffer (GTK_TEXT_VIEW(textview1)),execute_string.c_str(),-1);
     return( TRUE );
}  





gboolean
cb_timeout( gpointer data )
{
    gtk_text_buffer_set_text(gtk_text_view_get_buffer (GTK_TEXT_VIEW(textview2)),command_string.c_str(),-1);
    return( TRUE );
}

void * updater(void *args)
{
	while(1)
	{
		sleep(3);
	}
}

gpointer
thread_func( gpointer data )
{
    while( TRUE )
    {
        g_usleep( 10000 );
    }
    return( NULL );
}
  
  
  
  


GtkWidget*
create_window1 (void)
{
  execute_string = "";
  window1 = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_widget_set_size_request (window1, 500, 500);
  gtk_window_set_title (GTK_WINDOW (window1), _("Grid Computing Framework : Worker"));
  gtk_window_set_position (GTK_WINDOW (window1), GTK_WIN_POS_CENTER);
  strcpy(to_display,"in pthread");

  notebook1 = gtk_notebook_new ();
  gtk_widget_show (notebook1);
  gtk_container_add (GTK_CONTAINER (window1), notebook1);

  vbox1 = gtk_vbox_new (FALSE, 0);
  gtk_widget_show (vbox1);
  gtk_container_add (GTK_CONTAINER (notebook1), vbox1);

  label4 = gtk_label_new (_("Execution Details"));
  gtk_widget_show (label4);
  gtk_box_pack_start (GTK_BOX (vbox1), label4, FALSE, TRUE, 0);
  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_FILL);

  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
  gtk_widget_show (scrolledwindow1);
  gtk_box_pack_start (GTK_BOX (vbox1), scrolledwindow1, TRUE, TRUE, 0);
  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindow1), GTK_SHADOW_IN);

  textview1 = gtk_text_view_new ();
  gtk_text_view_set_editable((GtkTextView*)textview1,FALSE);
  gtk_widget_show (textview1);
  gtk_container_add (GTK_CONTAINER (scrolledwindow1), textview1);
  gtk_text_buffer_set_text (gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview1)), _("Task ID: \nTask Priority: \nTask Limit: \nCPU Nice: \nCPU Load: \n"), -1);
  execute_string = "Task ID: \nTask Priority: \nTask Limit: \nCPU Nice: \nCPU Load: \n";
  
  //label5 = gtk_label_new (_("Execution Progress"));
  //gtk_widget_show (label5);
  //gtk_box_pack_start (GTK_BOX (vbox1), label5, FALSE, FALSE, 0);

  //sprogressbar1 = gtk_progress_bar_new ();
  //gtk_widget_show (progressbar1);
  //gtk_box_pack_start (GTK_BOX (vbox1), progressbar1, FALSE, FALSE, 0);

  label1 = gtk_label_new (_("Execution Monitor"));
  gtk_widget_show (label1);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), label1);

  vbox2 = gtk_vbox_new (FALSE, 0);
  gtk_widget_show (vbox2);
  gtk_container_add (GTK_CONTAINER (notebook1), vbox2);

  label6 = gtk_label_new (_("Received Commands"));
  gtk_widget_show (label6);
  gtk_box_pack_start (GTK_BOX (vbox2), label6, FALSE, FALSE, 0);

  scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
  gtk_widget_show (scrolledwindow2);
  gtk_box_pack_start (GTK_BOX (vbox2), scrolledwindow2, TRUE, TRUE, 0);
  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_SHADOW_IN);

  textview2 = gtk_text_view_new ();
  gtk_text_view_set_editable((GtkTextView*)textview2,FALSE);
  gtk_widget_show (textview2);
  gtk_container_add (GTK_CONTAINER (scrolledwindow2), textview2);
  gtk_text_buffer_set_text (gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview2)), _(" "), -1);

  button1 = gtk_button_new_with_mnemonic (_("Clear"));
  gtk_widget_show (button1);
  gtk_box_pack_start (GTK_BOX (vbox2), button1, FALSE, FALSE, 0);

  label2 = gtk_label_new (_("Command Window"));
  gtk_widget_show (label2);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 1), label2);

  label7 = gtk_label_new (_("			<b>Grid Computing Framework</b>\n\n					Authors\n_________________________________________________________\n\n			<b>Gaurav Menghani (Red.Dragon) </b>\n			<b>Anil Harwani (Gohan)</b>\n			<b>Yash Londhe</b>\n			<b>Kalpesh Kagresha</b>\n_________________________________________________________\n\n	For any queries please please contact us\n	Released Under GPL (GNU PLublic License)\n	For any queries please contact us at:\n	<b>gridcomputingframework@gmail.com</b>\n"));
  gtk_widget_show (label7);
  gtk_label_set_use_markup (GTK_LABEL (label7), TRUE);
  gtk_container_add (GTK_CONTAINER (notebook1), label7);
  gtk_label_set_use_markup (GTK_LABEL (label7), TRUE);

  label3 = gtk_label_new (_("About GCF"));
  gtk_widget_show (label3);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), label3);

  g_signal_connect ((gpointer) window1, "delete_event",
                    G_CALLBACK (on_window1_delete_event),
                    NULL);
  g_signal_connect ((gpointer) window1, "destroy_event",
                    G_CALLBACK (on_window1_destroy_event),
                    NULL);
  g_signal_connect ((gpointer) button1, "clicked",
                    G_CALLBACK (on_button1_clicked),
                    NULL);

  /* Store pointers to all widgets, for use by lookup_widget(). */
  GLADE_HOOKUP_OBJECT_NO_REF (window1, window1, "window1");
  GLADE_HOOKUP_OBJECT (window1, notebook1, "notebook1");
  GLADE_HOOKUP_OBJECT (window1, vbox1, "vbox1");
  GLADE_HOOKUP_OBJECT (window1, label4, "label4");
  GLADE_HOOKUP_OBJECT (window1, scrolledwindow1, "scrolledwindow1");
  GLADE_HOOKUP_OBJECT (window1, textview1, "textview1");
  GLADE_HOOKUP_OBJECT (window1, label5, "label5");
  GLADE_HOOKUP_OBJECT (window1, progressbar1, "progressbar1");
  GLADE_HOOKUP_OBJECT (window1, label1, "label1");
  GLADE_HOOKUP_OBJECT (window1, vbox2, "vbox2");
  GLADE_HOOKUP_OBJECT (window1, label6, "label6");
  GLADE_HOOKUP_OBJECT (window1, scrolledwindow2, "scrolledwindow2");
  GLADE_HOOKUP_OBJECT (window1, textview2, "textview2");
  GLADE_HOOKUP_OBJECT (window1, button1, "button1");
  GLADE_HOOKUP_OBJECT (window1, label2, "label2");
  GLADE_HOOKUP_OBJECT (window1, label7, "label7");
  GLADE_HOOKUP_OBJECT (window1, label3, "label3");

  return window1;
}



void set_execution_view(char *message)
{ 
	 execute_string = (string)message;  
}

void set_command_view(char *message)
{
  
  string s1 = (string)message;
  to_disp.push_back(s1);

  command_string = "";
  for(int i=0;i<to_disp.size();i++)
   { command_string +=to_disp[i];;
     command_string +="\n"; 
   }
   
 }

void clear_command_window()
{	
	to_disp.clear();
	command_string = "";
	set_command_view((char *)command_string.c_str());	
}
